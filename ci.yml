name: ci

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - labeled

env:
  AWS_ACCOUNT_ID: 736296213899
  AWS_REGION: 'us-east-1'
  ECR_REPOSITORY: 'bronze/lula-pro-portal-fe'
  LABEL_ENVIRONMENT_MAP: 'deploy-dev=development,deploy-qa=qa,deploy-staging=staging,deploy-demo=demo'
  # SENTRY_ORG: 'lula-wu'
  # SENTRY_PROJECT: ''
  NODE_VERSION: 20
  SERVICE_DETAILS_MAP: |
    # - environment: development
    #   service:
    #   container:
    #   cluster: arn:aws:ecs:us-east-1:736296213899:cluster/
    #   health-check:
    #   cloudfront-distribution-id:
    # - environment: demo
    #   service:
    #   container:
    #   cluster: arn:aws:ecs:us-east-1:736296213899:cluster/
    #   health-check:
    #   cloudfront-distribution-id:
    # - environment: qa
    #   service:
    #   container:
    #   cluster: arn:aws:ecs:us-east-1:736296213899:cluster/
    #   health-check:
    #   cloudfront-distribution-id:
    - environment: staging
      service: core-pro-portal-fe
      container: fe
      cluster: arn:aws:ecs:us-east-1:736296213899:cluster/staging
      health-check: https://provider.lula-staging.com/
      cloudfront-distribution-id: E6I5V8WHC948Q
jobs:
  # validate that every PR has a release-major / release-minor / release-patch label on it
  release-type:
    runs-on: ubuntu-latest
    steps:
      - name: Check for Release Label
        run: |
          if echo "${{ toJSON(github.event.pull_request.labels.*.name) }}" | grep -qE '\b(release-major|release-minor|release-patch)\b'; then
            echo "Found a valid release label (major, minor, or patch). Check confirmed."
          else
            echo "No valid release label found. GitHub label must include patch/minor/major."
            exit 1
          fi

  # run npm install such that subsequent jobs have a runnable app
  install:
    runs-on: ubuntu-latest
    concurrency:
      group: install-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    outputs:
      cache-key: ${{ steps.setup-npm.outputs.cache-key }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Setup Node.js
        uses: actions/setup-node@a0853c24544627f65ddf259abe73b1d18a591444 # v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: Setup npm cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-cache-
      - name: Install dependencies
        run: npm ci
      - name: Upload workspace as artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: workspace
          path: |
               .
               !node_modules/          
          include-hidden-files: true
          retention-days: 1

  unit-tests:
    runs-on: ubuntu-latest
    concurrency:
      group: unit-tests-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    needs: install
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@a0853c24544627f65ddf259abe73b1d18a591444 # v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: Download workspace artifact
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v4
        with:
          name: workspace
          path: .
      - name: Install dependencies
        run: npm ci
      - name: Run Tests with Coverage
        run: npm run test -- --coverage
      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@fd88b7d7ccbaefd23d8f36f73b59db7a3d246602 # v6.0.0
        with:
          projectBaseDir: .
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      - name: SonarCloud Quality Gate Check
        uses: sonarsource/sonarqube-quality-gate-action@cf038b0e0cdecfa9e56c198bbb7d21d751d62c3b # v1.2.0
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  vulnerability-scan:
    concurrency:
      group: vulnerability-scan-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    runs-on: ubuntu-latest
    needs: install
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@a0853c24544627f65ddf259abe73b1d18a591444 # v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: Download workspace artifact
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v4
        with:
          name: workspace
          path: .
      - name: Run npm Audit
        run: npm audit --audit-level=moderate

  pre-deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: pre-deploy-${{ github.ref }}
      cancel-in-progress: false
    outputs:
      image: ${{ steps.build_image.outputs.image }}
      image_tag: ${{ steps.set_image_tag.outputs.image_tag }}
      deploy_envs: ${{ steps.setup_deployment_envs.outputs.deploy_envs }}

    env:
      labels: ${{ toJSON(github.event.pull_request.labels.*.name) }}
    permissions:
      contents: write
      id-token: write
      pull-requests: write
      issues: write
    steps:
      # Before we setup deployment environments, we need to confirm another PR doesn't have this label
      # (If the label was freshly applied)
      # So, we query via GraphQL (only way possible) to check if another PR has this label. If it does, we remove the one
      # that was just applied, and add a comment to the PR as to how come
      # Lastly, note we do this first, so that if the container build fails when a label is applied, we still remove it
      - name: Deploy Label - Verify Open PR
        if: ${{ github.event.action == 'labeled' && (github.event.label.name == 'deploy-dev' || github.event.label.name == 'deploy-demo' || github.event.label.name == 'deploy-qa' || github.event.label.name == 'deploy-staging') }}
        id: verify_pr_open
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPO: ${{ github.repository }}
          PULL_REQUEST_NUMBER: ${{ github.event.pull_request.number }}
          LABEL_NAME: ${{ github.event.label.name }}
        run: |
          PR_STATE=$(curl -sSf \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/$GITHUB_REPO/pulls/$PULL_REQUEST_NUMBER" \
          | jq -r '.state // empty' || true)

          if [ "$PR_STATE" != "closed" ]; then
            echo "PR #$PULL_REQUEST_NUMBER is not closed (state='$PR_STATE'). Skipping..."
            exit 0
          fi

          echo "PR #$PULL_REQUEST_NUMBER is closed. Removing label '$LABEL_NAME' and commenting."

          # Remove label
          curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -X DELETE \
            https://api.github.com/repos/$GITHUB_REPO/issues/$PULL_REQUEST_NUMBER/labels/$LABEL_NAME

          # Remove the label dynamically from the array using jq
          updated_labels=$(echo '${{ env.labels }}' | jq -c '[.[] | select(. != "$LABEL_NAME")]')
          echo "Updated labels after removal: $updated_labels"
          echo "labels=$updated_labels" >> $GITHUB_ENV

          # Add comment
          COMMENT="The requested deployment label \`$LABEL_NAME\` cannot be applied, as this PR is already closed. Only open PR's can be deployed - please open a new PR."
          curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -X POST -d "{\"body\": \"$COMMENT\"}" \
            https://api.github.com/repos/$GITHUB_REPO/issues/$PULL_REQUEST_NUMBER/comments

          # Fail the job when a PR is already closed
          exit 1
      - name: Deploy Label - Check Existing
        if: ${{ github.event.action == 'labeled' && (github.event.label.name == 'deploy-dev' || github.event.label.name == 'deploy-demo' || github.event.label.name == 'deploy-qa' || github.event.label.name == 'deploy-staging') }}
        id: query_pr_labels
        uses: octokit/graphql-action@8ad880e4d437783ea2ab17010324de1075228110 # v2.3.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          query: |
            {
              search(query: "repo:${{ github.event.repository.full_name }} is:pr state:open label:${{ github.event.label.name }}", type: ISSUE, first: 5) {
                issueCount
                nodes {
                  ... on PullRequest {
                    number
                    state
                    labels(first: 10, orderBy: {direction: DESC, field: CREATED_AT}) {
                      nodes {
                        name
                      }
                    }
                  }
                }
              }
            }
      - name: Deploy Label - Process GraphQL Query
        if: ${{ steps.query_pr_labels.outputs.data }}
        id: gql_dup_results
        run: |
          PR_COUNT=$(echo '${{ steps.query_pr_labels.outputs.data }}' | jq '.search.nodes | length')
          echo "Found $PR_COUNT open pull request(s) with this label."

          if [[ "$PR_COUNT" -gt "1" ]]; then
            CONFLICTING_PR=$(echo '${{ steps.query_pr_labels.outputs.data }}' | jq -r '.search.nodes[] | select(.number != ${{ github.event.pull_request.number }}) | .number')
            echo "has_conflict=true" >> $GITHUB_OUTPUT
            echo "conflicting_pr=${CONFLICTING_PR}" >> $GITHUB_OUTPUT
          else
            echo "has_conflict=false" >> $GITHUB_OUTPUT
          fi
      - name: Deploy Label - Remove if Exists
        id: remove-label
        if: ${{ steps.gql_dup_results && steps.gql_dup_results.outputs.has_conflict == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Conflict detected. Removing label and adding comment to PR..."

          # Remove label
          curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -X DELETE \
            https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/labels/${{ github.event.label.name }}

          # Remove the label dynamically from the array using jq
          updated_labels=$(echo '${{ env.labels }}' | jq -c '[.[] | select(. != "${{ github.event.label.name }}")]')
          echo "Updated labels after removal: $updated_labels"
          echo "labels=$updated_labels" >> $GITHUB_ENV

          # Add comment
          COMMENT="The environment for \`${{ github.event.label.name }}\` is already taken (#${{ steps.gql_dup_results.outputs.conflicting_pr }}). It has been automatically removed from this PR."
          curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -X POST -d "{\"body\": \"$COMMENT\"}" \
            https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments
      # Configure AWS + ECR Login for Docker
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 # v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-pipeline-role
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2
      - name: Set Docker Image Tag
        id: set_image_tag
        run: |
          echo "image_tag=prerelease-${{ github.event.pull_request.number }}-$(echo ${{ github.event.pull_request.head.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT
      - name: Check if Image Exists in ECR
        id: check_image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.set_image_tag.outputs.image_tag }}
        run: |
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Checking if image exists: $IMAGE_URI..."

          # Attempt to describe images and check for existence
          if aws ecr describe-images --repository-name "$ECR_REPOSITORY" --image-ids imageTag="$IMAGE_TAG" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Image exists: $IMAGE_URI"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Image does not exist: $IMAGE_URI"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
      - name: Checkout Code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        if: ${{ steps.check_image.outputs.exists == 'false' }}

      - name: Setup Docker Buildx
        if: ${{ steps.check_image.outputs.exists == 'false' }}
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3
      - name: Docker Build (Or skip and output existing tag...)
        id: build_image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.set_image_tag.outputs.image_tag }}
        run: |
          if [ "${{ steps.check_image.outputs.exists }}" == "false" ]; then
            docker buildx build --cache-from type=gha --cache-to type=gha,mode=max --push -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          fi

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
      - name: Setup Deployment Environments
        id: setup_deployment_envs
        run: |
          declare -A DEPLOY_LABEL_MAP
          IFS="," read -r -a label_mapping <<< "${LABEL_ENVIRONMENT_MAP}"

          for mapping in "${label_mapping[@]}"; do
            key="${mapping%%=*}"
            value="${mapping##*=}"
            DEPLOY_LABEL_MAP["$key"]="$value"
          done

          DEPLOY_ENVS="[]"
          FIRST_MATCHED_ENV=""

          for label in "${!DEPLOY_LABEL_MAP[@]}"; do
            if echo "${{ env.labels }}" | grep -q "$label"; then
              DEPLOY_ENVS=$(jq -c ". + [\"${DEPLOY_LABEL_MAP[$label]}\"]" <<< "$DEPLOY_ENVS")
              if [[ -z "$FIRST_MATCHED_ENV" ]]; then
                FIRST_MATCHED_ENV="${DEPLOY_LABEL_MAP[$label]}"
              fi
            fi
          done

          echo "deploy_envs=${DEPLOY_ENVS}" >> $GITHUB_OUTPUT
  deploy:
    needs: pre-deploy
    if: ${{ needs.pre-deploy.outputs.deploy_envs != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.pre-deploy.outputs.deploy_envs) }}
    environment: ${{matrix.environment}}
    concurrency:
      group: ${{matrix.environment}}-deploy
      cancel-in-progress: false
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Debug deployment values
        run: |
          echo "Environment: ${{matrix.environment}}"
          echo "Deploying service mapped to this env"

      - name: Extract Values From Service-Details Map
        id: ecs-config
        env:
          SERVICE_DETAILS_MAP: ${{ env.SERVICE_DETAILS_MAP }}
          ENVIRONMENT: ${{matrix.environment}}
        run: |
          echo "Extracting details for environment: $ENVIRONMENT..."

          # Variables to store extracted values
          selected_service=""
          selected_cluster=""
          selected_container=""
          selected_health_check=""
          selected_cloudfront_dist_id=""

          # Loop through the map and find the matching environment
          while IFS= read -r line; do
            if echo "$line" | grep -q "environment:"; then
              current_env=$(echo "$line" | awk -F'environment: ' '{print $2}' | xargs)
            fi
            if [[ "$current_env" == "$ENVIRONMENT" ]] && echo "$line" | grep -q "service:"; then
              selected_service=$(echo "$line" | awk -F'service: ' '{print $2}' | xargs)
            fi
            if [[ "$current_env" == "$ENVIRONMENT" ]] && echo "$line" | grep -q "cluster:"; then
              selected_cluster=$(echo "$line" | awk -F'cluster: ' '{print $2}' | xargs)
            fi
            if [[ "$current_env" == "$ENVIRONMENT" ]] && echo "$line" | grep -q "container:"; then
              selected_container=$(echo "$line" | awk -F'container: ' '{print $2}' | xargs)
            fi
            if [[ "$current_env" == "$ENVIRONMENT" ]] && echo "$line" | grep -q "health-check:"; then
              selected_health_check=$(echo "$line" | awk -F'health-check: ' '{print $2}' | xargs)
            fi
            if [[ "$current_env" == "$ENVIRONMENT" ]] && echo "$line" | grep -q "cloudfront-distribution-id:"; then
              selected_cloudfront_dist_id=$(echo "$line" | awk -F'cloudfront-distribution-id: ' '{print $2}' | xargs)
            fi

          done <<< "$SERVICE_DETAILS_MAP"

          # Set GitHub environment variables
          echo "ECS_SERVICE=$selected_service" >> $GITHUB_ENV
          echo "ECS_CLUSTER=$selected_cluster" >> $GITHUB_ENV
          echo "CONTAINER_NAME=$selected_container" >> $GITHUB_ENV
          echo "HEALTH_CHECK_URL=$selected_health_check" >> $GITHUB_ENV
          echo "CLOUDFRONT_DISTRIBUTION_ID=$selected_cloudfront_dist_id" >> $GITHUB_ENV

          # Print for debugging
          echo "Set ECS_SERVICE=$selected_service"
          echo "Set ECS_CLUSTER=$selected_cluster"
          echo "Set CONTAINER_NAME=$selected_container"
          echo "Set HEALTH_CHECK_URL=$selected_health_check"
          echo "Set CLOUDFRONT_DISTRIBUTION_ID=$selected_cloudfront_dist_id"

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 # v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-pipeline-role
          role-session-name: GitHub_to_AWS_via_FederatedOIDC_Deploy_${{ matrix.environment }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@5cb8c74c1b1ecaec4c8ea82eff82c009333509ce # v1
        with:
          task-definition: .aws/task-definition/${{matrix.environment}}.json
          container-name: ${{env.CONTAINER_NAME}}
          image: ${{ needs.pre-deploy.outputs.image }}

      - name: Deploy Amazon ECS task definition
        id: ecs-deploy
        uses: aws-actions/amazon-ecs-deploy-task-definition@1beffbdddb3eb5f83c7a746c3e9bafeccdccbbaa # v2
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Check if deployment was successful
        id: check-deployment
        run: |
          CURRENT_TASK_DEF_ARN=$(aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --query services[0].deployments[0].taskDefinition | jq -r ".")
          NEW_TASK_DEF_ARN=${{ steps.ecs-deploy.outputs.task-definition-arn }}
          echo "Current task arn: $CURRENT_TASK_DEF_ARN"
          echo "New task arn: $NEW_TASK_DEF_ARN"
          if [ "$CURRENT_TASK_DEF_ARN" != "$NEW_TASK_DEF_ARN" ]; then
            echo "Deployment failed."
            exit 1
          fi

      - name: Invalidate CloudFront Distribution
        id: cloudfront-invalidate
        run: |
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ env.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          echo "invalidation_id=$INVALIDATION_ID" >> $GITHUB_OUTPUT
          echo "Created invalidation: $INVALIDATION_ID"

      - name: Wait for CloudFront Invalidation
        run: |
          echo "Waiting for CloudFront invalidation to complete..."
          aws cloudfront wait invalidation-completed \
            --distribution-id ${{ env.CLOUDFRONT_DISTRIBUTION_ID }} \
            --id ${{ steps.cloudfront-invalidate.outputs.invalidation_id }}
          echo "CloudFront invalidation completed"

      #- name: Notify Sentry
      #  uses: getsentry/action-release@v1
      #  with:
      #    environment: ${{matrix.environment}}
      #    version: ${{ needs.pre-deploy.outputs.image_tag }}
      #    ignore_missing: true
      #    set_commits: skip
      #    sourcemaps: "./dist"
      #  env:
      #    SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
      #    SENTRY_ORG: ${{ env.SENTRY_ORG }}
      #    SENTRY_PROJECT: ${{ env.SENTRY_PROJECT }}
      - name: Format environment to Title Case
        id: format-env
        run: |
            ENVIRONMENT="${{matrix.environment}}"
            TITLE_CASE_ENVIRONMENT=$(echo "$ENVIRONMENT" | sed -E 's/(^|_)([a-z])/\U\2/g' | sed 's/_/ /g')
            echo "titleCaseEnvironment=$TITLE_CASE_ENVIRONMENT" >> $GITHUB_OUTPUT

      # - name: Post blocks to a Slack channel
      #   uses: slackapi/slack-github-action@91efab103c0de0a537f72a35f6b8cda0ee76bf0a # v2.1.1
      #   with:
      #       method: chat.postMessage
      #       token: ${{ secrets.SLACK_BOT_TOKEN }}
      #       payload: |
      #         channel: ${{ secrets.SLACK_DEPLOYMENT_CHANNEL_ID }}
      #         text: ":house_buildings: Pro Portal (FE) has been deployed to [<${{env.HEALTH_CHECK_URL}}|${{ steps.format-env.outputs.titleCaseEnvironment }}>] :wrench:"
      #         blocks:
      #           - type: "section"
      #             text:
      #               type: "mrkdwn"
      #               text: ":house_buildings: Pro Portal (FE) has been successfully deployed to [*<${{env.HEALTH_CHECK_URL}}|${{ steps.format-env.outputs.titleCaseEnvironment }}>*] :hammer_and_wrench:"
      #           - type: "context"
      #             elements:
      #               - type: "mrkdwn"
      #                 text: ":github: *PR*: <${{ github.event.pull_request.html_url }}|#${{ github.event.pull_request.number }}>"
      #               - type: "mrkdwn"
      #                 text: ":label: *Tag*: ${{ needs.pre-deploy.outputs.image_tag }}"
